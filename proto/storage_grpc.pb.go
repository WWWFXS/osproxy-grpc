// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.20.1
// source: storage.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// HealthCheckClient is the client API for HealthCheck service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HealthCheckClient interface {
	PingHandler(ctx context.Context, in *NULLRequest, opts ...grpc.CallOption) (*HelloResponse, error)
	HealthCheckHandler(ctx context.Context, in *NULLRequest, opts ...grpc.CallOption) (*HelloResponse, error)
}

type healthCheckClient struct {
	cc grpc.ClientConnInterface
}

func NewHealthCheckClient(cc grpc.ClientConnInterface) HealthCheckClient {
	return &healthCheckClient{cc}
}

func (c *healthCheckClient) PingHandler(ctx context.Context, in *NULLRequest, opts ...grpc.CallOption) (*HelloResponse, error) {
	out := new(HelloResponse)
	err := c.cc.Invoke(ctx, "/proto.HealthCheck/PingHandler", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthCheckClient) HealthCheckHandler(ctx context.Context, in *NULLRequest, opts ...grpc.CallOption) (*HelloResponse, error) {
	out := new(HelloResponse)
	err := c.cc.Invoke(ctx, "/proto.HealthCheck/HealthCheckHandler", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HealthCheckServer is the server API for HealthCheck service.
// All implementations must embed UnimplementedHealthCheckServer
// for forward compatibility
type HealthCheckServer interface {
	PingHandler(context.Context, *NULLRequest) (*HelloResponse, error)
	HealthCheckHandler(context.Context, *NULLRequest) (*HelloResponse, error)
	mustEmbedUnimplementedHealthCheckServer()
}

// UnimplementedHealthCheckServer must be embedded to have forward compatible implementations.
type UnimplementedHealthCheckServer struct {
}

func (UnimplementedHealthCheckServer) PingHandler(context.Context, *NULLRequest) (*HelloResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PingHandler not implemented")
}
func (UnimplementedHealthCheckServer) HealthCheckHandler(context.Context, *NULLRequest) (*HelloResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheckHandler not implemented")
}
func (UnimplementedHealthCheckServer) mustEmbedUnimplementedHealthCheckServer() {}

// UnsafeHealthCheckServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HealthCheckServer will
// result in compilation errors.
type UnsafeHealthCheckServer interface {
	mustEmbedUnimplementedHealthCheckServer()
}

func RegisterHealthCheckServer(s grpc.ServiceRegistrar, srv HealthCheckServer) {
	s.RegisterService(&HealthCheck_ServiceDesc, srv)
}

func _HealthCheck_PingHandler_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NULLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthCheckServer).PingHandler(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.HealthCheck/PingHandler",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthCheckServer).PingHandler(ctx, req.(*NULLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthCheck_HealthCheckHandler_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NULLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthCheckServer).HealthCheckHandler(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.HealthCheck/HealthCheckHandler",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthCheckServer).HealthCheckHandler(ctx, req.(*NULLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// HealthCheck_ServiceDesc is the grpc.ServiceDesc for HealthCheck service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HealthCheck_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.HealthCheck",
	HandlerType: (*HealthCheckServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PingHandler",
			Handler:    _HealthCheck_PingHandler_Handler,
		},
		{
			MethodName: "HealthCheckHandler",
			Handler:    _HealthCheck_HealthCheckHandler_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "storage.proto",
}

// GreeterClient is the client API for Greeter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GreeterClient interface {
	SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloResponse, error)
}

type greeterClient struct {
	cc grpc.ClientConnInterface
}

func NewGreeterClient(cc grpc.ClientConnInterface) GreeterClient {
	return &greeterClient{cc}
}

func (c *greeterClient) SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloResponse, error) {
	out := new(HelloResponse)
	err := c.cc.Invoke(ctx, "/proto.Greeter/SayHello", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GreeterServer is the server API for Greeter service.
// All implementations must embed UnimplementedGreeterServer
// for forward compatibility
type GreeterServer interface {
	SayHello(context.Context, *HelloRequest) (*HelloResponse, error)
	mustEmbedUnimplementedGreeterServer()
}

// UnimplementedGreeterServer must be embedded to have forward compatible implementations.
type UnimplementedGreeterServer struct {
}

func (UnimplementedGreeterServer) SayHello(context.Context, *HelloRequest) (*HelloResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SayHello not implemented")
}
func (UnimplementedGreeterServer) mustEmbedUnimplementedGreeterServer() {}

// UnsafeGreeterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GreeterServer will
// result in compilation errors.
type UnsafeGreeterServer interface {
	mustEmbedUnimplementedGreeterServer()
}

func RegisterGreeterServer(s grpc.ServiceRegistrar, srv GreeterServer) {
	s.RegisterService(&Greeter_ServiceDesc, srv)
}

func _Greeter_SayHello_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HelloRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GreeterServer).SayHello(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Greeter/SayHello",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GreeterServer).SayHello(ctx, req.(*HelloRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Greeter_ServiceDesc is the grpc.ServiceDesc for Greeter service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Greeter_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Greeter",
	HandlerType: (*GreeterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SayHello",
			Handler:    _Greeter_SayHello_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "storage.proto",
}

// LinkClient is the client API for Link service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LinkClient interface {
	UploadLinkHandler(ctx context.Context, in *GenUploadReq, opts ...grpc.CallOption) (*GenUploadResp, error)
	DownloadLinkHandler(ctx context.Context, in *GenDownloadReq, opts ...grpc.CallOption) (*GenDownloadResp, error)
}

type linkClient struct {
	cc grpc.ClientConnInterface
}

func NewLinkClient(cc grpc.ClientConnInterface) LinkClient {
	return &linkClient{cc}
}

func (c *linkClient) UploadLinkHandler(ctx context.Context, in *GenUploadReq, opts ...grpc.CallOption) (*GenUploadResp, error) {
	out := new(GenUploadResp)
	err := c.cc.Invoke(ctx, "/proto.Link/UploadLinkHandler", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *linkClient) DownloadLinkHandler(ctx context.Context, in *GenDownloadReq, opts ...grpc.CallOption) (*GenDownloadResp, error) {
	out := new(GenDownloadResp)
	err := c.cc.Invoke(ctx, "/proto.Link/DownloadLinkHandler", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LinkServer is the server API for Link service.
// All implementations must embed UnimplementedLinkServer
// for forward compatibility
type LinkServer interface {
	UploadLinkHandler(context.Context, *GenUploadReq) (*GenUploadResp, error)
	DownloadLinkHandler(context.Context, *GenDownloadReq) (*GenDownloadResp, error)
	mustEmbedUnimplementedLinkServer()
}

// UnimplementedLinkServer must be embedded to have forward compatible implementations.
type UnimplementedLinkServer struct {
}

func (UnimplementedLinkServer) UploadLinkHandler(context.Context, *GenUploadReq) (*GenUploadResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadLinkHandler not implemented")
}
func (UnimplementedLinkServer) DownloadLinkHandler(context.Context, *GenDownloadReq) (*GenDownloadResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadLinkHandler not implemented")
}
func (UnimplementedLinkServer) mustEmbedUnimplementedLinkServer() {}

// UnsafeLinkServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LinkServer will
// result in compilation errors.
type UnsafeLinkServer interface {
	mustEmbedUnimplementedLinkServer()
}

func RegisterLinkServer(s grpc.ServiceRegistrar, srv LinkServer) {
	s.RegisterService(&Link_ServiceDesc, srv)
}

func _Link_UploadLinkHandler_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenUploadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LinkServer).UploadLinkHandler(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Link/UploadLinkHandler",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LinkServer).UploadLinkHandler(ctx, req.(*GenUploadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Link_DownloadLinkHandler_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenDownloadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LinkServer).DownloadLinkHandler(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Link/DownloadLinkHandler",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LinkServer).DownloadLinkHandler(ctx, req.(*GenDownloadReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Link_ServiceDesc is the grpc.ServiceDesc for Link service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Link_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Link",
	HandlerType: (*LinkServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UploadLinkHandler",
			Handler:    _Link_UploadLinkHandler_Handler,
		},
		{
			MethodName: "DownloadLinkHandler",
			Handler:    _Link_DownloadLinkHandler_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "storage.proto",
}

// ResumeClient is the client API for Resume service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ResumeClient interface {
	ResumeHandler(ctx context.Context, in *ResumeReq, opts ...grpc.CallOption) (*ResumeResp, error)
}

type resumeClient struct {
	cc grpc.ClientConnInterface
}

func NewResumeClient(cc grpc.ClientConnInterface) ResumeClient {
	return &resumeClient{cc}
}

func (c *resumeClient) ResumeHandler(ctx context.Context, in *ResumeReq, opts ...grpc.CallOption) (*ResumeResp, error) {
	out := new(ResumeResp)
	err := c.cc.Invoke(ctx, "/proto.Resume/ResumeHandler", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ResumeServer is the server API for Resume service.
// All implementations must embed UnimplementedResumeServer
// for forward compatibility
type ResumeServer interface {
	ResumeHandler(context.Context, *ResumeReq) (*ResumeResp, error)
	mustEmbedUnimplementedResumeServer()
}

// UnimplementedResumeServer must be embedded to have forward compatible implementations.
type UnimplementedResumeServer struct {
}

func (UnimplementedResumeServer) ResumeHandler(context.Context, *ResumeReq) (*ResumeResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResumeHandler not implemented")
}
func (UnimplementedResumeServer) mustEmbedUnimplementedResumeServer() {}

// UnsafeResumeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ResumeServer will
// result in compilation errors.
type UnsafeResumeServer interface {
	mustEmbedUnimplementedResumeServer()
}

func RegisterResumeServer(s grpc.ServiceRegistrar, srv ResumeServer) {
	s.RegisterService(&Resume_ServiceDesc, srv)
}

func _Resume_ResumeHandler_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResumeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResumeServer).ResumeHandler(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Resume/ResumeHandler",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResumeServer).ResumeHandler(ctx, req.(*ResumeReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Resume_ServiceDesc is the grpc.ServiceDesc for Resume service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Resume_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Resume",
	HandlerType: (*ResumeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ResumeHandler",
			Handler:    _Resume_ResumeHandler_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "storage.proto",
}

// ProxyClient is the client API for Proxy service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProxyClient interface {
	ProxyHandler(ctx context.Context, in *ProxyReq, opts ...grpc.CallOption) (*ProxyResp, error)
}

type proxyClient struct {
	cc grpc.ClientConnInterface
}

func NewProxyClient(cc grpc.ClientConnInterface) ProxyClient {
	return &proxyClient{cc}
}

func (c *proxyClient) ProxyHandler(ctx context.Context, in *ProxyReq, opts ...grpc.CallOption) (*ProxyResp, error) {
	out := new(ProxyResp)
	err := c.cc.Invoke(ctx, "/proto.Proxy/ProxyHandler", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProxyServer is the server API for Proxy service.
// All implementations must embed UnimplementedProxyServer
// for forward compatibility
type ProxyServer interface {
	ProxyHandler(context.Context, *ProxyReq) (*ProxyResp, error)
	mustEmbedUnimplementedProxyServer()
}

// UnimplementedProxyServer must be embedded to have forward compatible implementations.
type UnimplementedProxyServer struct {
}

func (UnimplementedProxyServer) ProxyHandler(context.Context, *ProxyReq) (*ProxyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProxyHandler not implemented")
}
func (UnimplementedProxyServer) mustEmbedUnimplementedProxyServer() {}

// UnsafeProxyServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProxyServer will
// result in compilation errors.
type UnsafeProxyServer interface {
	mustEmbedUnimplementedProxyServer()
}

func RegisterProxyServer(s grpc.ServiceRegistrar, srv ProxyServer) {
	s.RegisterService(&Proxy_ServiceDesc, srv)
}

func _Proxy_ProxyHandler_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProxyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).ProxyHandler(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Proxy/ProxyHandler",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).ProxyHandler(ctx, req.(*ProxyReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Proxy_ServiceDesc is the grpc.ServiceDesc for Proxy service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Proxy_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Proxy",
	HandlerType: (*ProxyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ProxyHandler",
			Handler:    _Proxy_ProxyHandler_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "storage.proto",
}

// CheckPointClient is the client API for CheckPoint service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CheckPointClient interface {
	CheckPointHandler(ctx context.Context, in *CPReq, opts ...grpc.CallOption) (*CPResp, error)
}

type checkPointClient struct {
	cc grpc.ClientConnInterface
}

func NewCheckPointClient(cc grpc.ClientConnInterface) CheckPointClient {
	return &checkPointClient{cc}
}

func (c *checkPointClient) CheckPointHandler(ctx context.Context, in *CPReq, opts ...grpc.CallOption) (*CPResp, error) {
	out := new(CPResp)
	err := c.cc.Invoke(ctx, "/proto.CheckPoint/CheckPointHandler", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CheckPointServer is the server API for CheckPoint service.
// All implementations must embed UnimplementedCheckPointServer
// for forward compatibility
type CheckPointServer interface {
	CheckPointHandler(context.Context, *CPReq) (*CPResp, error)
	mustEmbedUnimplementedCheckPointServer()
}

// UnimplementedCheckPointServer must be embedded to have forward compatible implementations.
type UnimplementedCheckPointServer struct {
}

func (UnimplementedCheckPointServer) CheckPointHandler(context.Context, *CPReq) (*CPResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckPointHandler not implemented")
}
func (UnimplementedCheckPointServer) mustEmbedUnimplementedCheckPointServer() {}

// UnsafeCheckPointServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CheckPointServer will
// result in compilation errors.
type UnsafeCheckPointServer interface {
	mustEmbedUnimplementedCheckPointServer()
}

func RegisterCheckPointServer(s grpc.ServiceRegistrar, srv CheckPointServer) {
	s.RegisterService(&CheckPoint_ServiceDesc, srv)
}

func _CheckPoint_CheckPointHandler_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CPReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CheckPointServer).CheckPointHandler(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CheckPoint/CheckPointHandler",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CheckPointServer).CheckPointHandler(ctx, req.(*CPReq))
	}
	return interceptor(ctx, in, info, handler)
}

// CheckPoint_ServiceDesc is the grpc.ServiceDesc for CheckPoint service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CheckPoint_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.CheckPoint",
	HandlerType: (*CheckPointServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CheckPointHandler",
			Handler:    _CheckPoint_CheckPointHandler_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "storage.proto",
}

// DownloadClient is the client API for Download service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DownloadClient interface {
	DownloadHandler(ctx context.Context, in *DownloadReq, opts ...grpc.CallOption) (Download_DownloadHandlerClient, error)
}

type downloadClient struct {
	cc grpc.ClientConnInterface
}

func NewDownloadClient(cc grpc.ClientConnInterface) DownloadClient {
	return &downloadClient{cc}
}

func (c *downloadClient) DownloadHandler(ctx context.Context, in *DownloadReq, opts ...grpc.CallOption) (Download_DownloadHandlerClient, error) {
	stream, err := c.cc.NewStream(ctx, &Download_ServiceDesc.Streams[0], "/proto.Download/DownloadHandler", opts...)
	if err != nil {
		return nil, err
	}
	x := &downloadDownloadHandlerClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Download_DownloadHandlerClient interface {
	Recv() (*DownloadResp, error)
	grpc.ClientStream
}

type downloadDownloadHandlerClient struct {
	grpc.ClientStream
}

func (x *downloadDownloadHandlerClient) Recv() (*DownloadResp, error) {
	m := new(DownloadResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// DownloadServer is the server API for Download service.
// All implementations must embed UnimplementedDownloadServer
// for forward compatibility
type DownloadServer interface {
	DownloadHandler(*DownloadReq, Download_DownloadHandlerServer) error
	mustEmbedUnimplementedDownloadServer()
}

// UnimplementedDownloadServer must be embedded to have forward compatible implementations.
type UnimplementedDownloadServer struct {
}

func (UnimplementedDownloadServer) DownloadHandler(*DownloadReq, Download_DownloadHandlerServer) error {
	return status.Errorf(codes.Unimplemented, "method DownloadHandler not implemented")
}
func (UnimplementedDownloadServer) mustEmbedUnimplementedDownloadServer() {}

// UnsafeDownloadServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DownloadServer will
// result in compilation errors.
type UnsafeDownloadServer interface {
	mustEmbedUnimplementedDownloadServer()
}

func RegisterDownloadServer(s grpc.ServiceRegistrar, srv DownloadServer) {
	s.RegisterService(&Download_ServiceDesc, srv)
}

func _Download_DownloadHandler_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DownloadReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DownloadServer).DownloadHandler(m, &downloadDownloadHandlerServer{stream})
}

type Download_DownloadHandlerServer interface {
	Send(*DownloadResp) error
	grpc.ServerStream
}

type downloadDownloadHandlerServer struct {
	grpc.ServerStream
}

func (x *downloadDownloadHandlerServer) Send(m *DownloadResp) error {
	return x.ServerStream.SendMsg(m)
}

// Download_ServiceDesc is the grpc.ServiceDesc for Download service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Download_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Download",
	HandlerType: (*DownloadServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "DownloadHandler",
			Handler:       _Download_DownloadHandler_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "storage.proto",
}

// UploadClient is the client API for Upload service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UploadClient interface {
	UploadSingleHandler(ctx context.Context, opts ...grpc.CallOption) (Upload_UploadSingleHandlerClient, error)
	UploadSingleProxyHandler(ctx context.Context, opts ...grpc.CallOption) (Upload_UploadSingleProxyHandlerClient, error)
	UploadMultiPartHandler(ctx context.Context, opts ...grpc.CallOption) (Upload_UploadMultiPartHandlerClient, error)
	UploadMergeHandler(ctx context.Context, in *UploadMergeReq, opts ...grpc.CallOption) (*UploadMergeResp, error)
}

type uploadClient struct {
	cc grpc.ClientConnInterface
}

func NewUploadClient(cc grpc.ClientConnInterface) UploadClient {
	return &uploadClient{cc}
}

func (c *uploadClient) UploadSingleHandler(ctx context.Context, opts ...grpc.CallOption) (Upload_UploadSingleHandlerClient, error) {
	stream, err := c.cc.NewStream(ctx, &Upload_ServiceDesc.Streams[0], "/proto.Upload/UploadSingleHandler", opts...)
	if err != nil {
		return nil, err
	}
	x := &uploadUploadSingleHandlerClient{stream}
	return x, nil
}

type Upload_UploadSingleHandlerClient interface {
	Send(*UploadSingleReq) error
	CloseAndRecv() (*UploadSingleResp, error)
	grpc.ClientStream
}

type uploadUploadSingleHandlerClient struct {
	grpc.ClientStream
}

func (x *uploadUploadSingleHandlerClient) Send(m *UploadSingleReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *uploadUploadSingleHandlerClient) CloseAndRecv() (*UploadSingleResp, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UploadSingleResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *uploadClient) UploadSingleProxyHandler(ctx context.Context, opts ...grpc.CallOption) (Upload_UploadSingleProxyHandlerClient, error) {
	stream, err := c.cc.NewStream(ctx, &Upload_ServiceDesc.Streams[1], "/proto.Upload/UploadSingleProxyHandler", opts...)
	if err != nil {
		return nil, err
	}
	x := &uploadUploadSingleProxyHandlerClient{stream}
	return x, nil
}

type Upload_UploadSingleProxyHandlerClient interface {
	Send(*UploadSingleReq) error
	CloseAndRecv() (*UploadSingleResp, error)
	grpc.ClientStream
}

type uploadUploadSingleProxyHandlerClient struct {
	grpc.ClientStream
}

func (x *uploadUploadSingleProxyHandlerClient) Send(m *UploadSingleReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *uploadUploadSingleProxyHandlerClient) CloseAndRecv() (*UploadSingleResp, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UploadSingleResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *uploadClient) UploadMultiPartHandler(ctx context.Context, opts ...grpc.CallOption) (Upload_UploadMultiPartHandlerClient, error) {
	stream, err := c.cc.NewStream(ctx, &Upload_ServiceDesc.Streams[2], "/proto.Upload/UploadMultiPartHandler", opts...)
	if err != nil {
		return nil, err
	}
	x := &uploadUploadMultiPartHandlerClient{stream}
	return x, nil
}

type Upload_UploadMultiPartHandlerClient interface {
	Send(*UploadMultiReq) error
	CloseAndRecv() (*UploadMultiResp, error)
	grpc.ClientStream
}

type uploadUploadMultiPartHandlerClient struct {
	grpc.ClientStream
}

func (x *uploadUploadMultiPartHandlerClient) Send(m *UploadMultiReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *uploadUploadMultiPartHandlerClient) CloseAndRecv() (*UploadMultiResp, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UploadMultiResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *uploadClient) UploadMergeHandler(ctx context.Context, in *UploadMergeReq, opts ...grpc.CallOption) (*UploadMergeResp, error) {
	out := new(UploadMergeResp)
	err := c.cc.Invoke(ctx, "/proto.Upload/UploadMergeHandler", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UploadServer is the server API for Upload service.
// All implementations must embed UnimplementedUploadServer
// for forward compatibility
type UploadServer interface {
	UploadSingleHandler(Upload_UploadSingleHandlerServer) error
	UploadSingleProxyHandler(Upload_UploadSingleProxyHandlerServer) error
	UploadMultiPartHandler(Upload_UploadMultiPartHandlerServer) error
	UploadMergeHandler(context.Context, *UploadMergeReq) (*UploadMergeResp, error)
	mustEmbedUnimplementedUploadServer()
}

// UnimplementedUploadServer must be embedded to have forward compatible implementations.
type UnimplementedUploadServer struct {
}

func (UnimplementedUploadServer) UploadSingleHandler(Upload_UploadSingleHandlerServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadSingleHandler not implemented")
}
func (UnimplementedUploadServer) UploadSingleProxyHandler(Upload_UploadSingleProxyHandlerServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadSingleProxyHandler not implemented")
}
func (UnimplementedUploadServer) UploadMultiPartHandler(Upload_UploadMultiPartHandlerServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadMultiPartHandler not implemented")
}
func (UnimplementedUploadServer) UploadMergeHandler(context.Context, *UploadMergeReq) (*UploadMergeResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadMergeHandler not implemented")
}
func (UnimplementedUploadServer) mustEmbedUnimplementedUploadServer() {}

// UnsafeUploadServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UploadServer will
// result in compilation errors.
type UnsafeUploadServer interface {
	mustEmbedUnimplementedUploadServer()
}

func RegisterUploadServer(s grpc.ServiceRegistrar, srv UploadServer) {
	s.RegisterService(&Upload_ServiceDesc, srv)
}

func _Upload_UploadSingleHandler_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(UploadServer).UploadSingleHandler(&uploadUploadSingleHandlerServer{stream})
}

type Upload_UploadSingleHandlerServer interface {
	SendAndClose(*UploadSingleResp) error
	Recv() (*UploadSingleReq, error)
	grpc.ServerStream
}

type uploadUploadSingleHandlerServer struct {
	grpc.ServerStream
}

func (x *uploadUploadSingleHandlerServer) SendAndClose(m *UploadSingleResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *uploadUploadSingleHandlerServer) Recv() (*UploadSingleReq, error) {
	m := new(UploadSingleReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Upload_UploadSingleProxyHandler_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(UploadServer).UploadSingleProxyHandler(&uploadUploadSingleProxyHandlerServer{stream})
}

type Upload_UploadSingleProxyHandlerServer interface {
	SendAndClose(*UploadSingleResp) error
	Recv() (*UploadSingleReq, error)
	grpc.ServerStream
}

type uploadUploadSingleProxyHandlerServer struct {
	grpc.ServerStream
}

func (x *uploadUploadSingleProxyHandlerServer) SendAndClose(m *UploadSingleResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *uploadUploadSingleProxyHandlerServer) Recv() (*UploadSingleReq, error) {
	m := new(UploadSingleReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Upload_UploadMultiPartHandler_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(UploadServer).UploadMultiPartHandler(&uploadUploadMultiPartHandlerServer{stream})
}

type Upload_UploadMultiPartHandlerServer interface {
	SendAndClose(*UploadMultiResp) error
	Recv() (*UploadMultiReq, error)
	grpc.ServerStream
}

type uploadUploadMultiPartHandlerServer struct {
	grpc.ServerStream
}

func (x *uploadUploadMultiPartHandlerServer) SendAndClose(m *UploadMultiResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *uploadUploadMultiPartHandlerServer) Recv() (*UploadMultiReq, error) {
	m := new(UploadMultiReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Upload_UploadMergeHandler_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadMergeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadServer).UploadMergeHandler(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Upload/UploadMergeHandler",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadServer).UploadMergeHandler(ctx, req.(*UploadMergeReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Upload_ServiceDesc is the grpc.ServiceDesc for Upload service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Upload_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Upload",
	HandlerType: (*UploadServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UploadMergeHandler",
			Handler:    _Upload_UploadMergeHandler_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UploadSingleHandler",
			Handler:       _Upload_UploadSingleHandler_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "UploadSingleProxyHandler",
			Handler:       _Upload_UploadSingleProxyHandler_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "UploadMultiPartHandler",
			Handler:       _Upload_UploadMultiPartHandler_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "storage.proto",
}
